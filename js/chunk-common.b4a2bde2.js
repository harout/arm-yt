(globalThis["webpackChunkyt_stats_quasar"]=globalThis["webpackChunkyt_stats_quasar"]||[]).push([[64],{8504:(e,n,t)=>{"use strict";t.d(n,{Z:()=>r});t(9665),t(5231),t(7725),t(3075),t(548),t(9359),t(6408);var a=t(425);class r{constructor(){}static get unngroupedGroupingName(){return"[Ungrouped]"}async loadDatabase(e){const n=t(1584),r=n({locateFile:e=>`${e}`}),c=fetch("data/channel_stats.db.encrypted").then((e=>e.text())),[s,u]=await Promise.all([r,c]),i=a.AES.decrypt(u.toString(),e);try{this.db=new s.Database(this._cryptJsWordArrayToUint8Array(i))}catch{return Promise.reject()}return Promise.resolve(!0)}getBasicStatsForPeriod(e,n){const t="SELECT\n            *\n          FROM\n            channels\n          LEFT JOIN\n            (SELECT\n              channelId,\n              SUM(correctedViewsDelta) AS totalViews,\n              MAX(correctedSubscribers) AS maxSubscribers,\n              AVG(correctedSubscribers) AS avgSubscribers\n            FROM\n              daily_data\n            WHERE\n              DATE(captureDate, 'unixepoch') >= DATE($start, 'unixepoch') AND\n              DATE(captureDate, 'unixepoch') <= DATE($end, 'unixepoch')\n            GROUP BY channelId) AS dd\n          ON\n            dd.channelId = channels.id",a=this._execQueryAndFetchResults(t,{$start:e,$end:n}),r=a.map((e=>e.totalViews)).reduce(((e,n)=>Number(e)+Number(n)));return a.forEach((e=>{const n=null==e.totalViews?0n:e.totalViews,t=Number(10000n*n),a=t/r;e.share=(a/100).toFixed(1)})),a}getViewsByChannel(e,n,t){const a="\n          SELECT\n            channels.name,\n            channels.id\n          FROM\n            channels\n          LEFT JOIN\n            (SELECT\n              SUM(correctedViewsDelta) AS views,\n              channelId\n             FROM\n              daily_data\n             WHERE\n              DATE(captureDate, 'unixepoch') >= DATE($start, 'unixepoch') AND\n              DATE(captureDate, 'unixepoch') <= DATE($end, 'unixepoch')\n             GROUP BY channelId\n            ) AS dd\n          ON\n            dd.channelId = channels.id\n          ORDER BY\n            dd.views DESC\n          LIMIT $limit",r=this._execQueryAndFetchResults(a,{$start:e,$end:n,$limit:t}),c=[];return r.forEach((t=>{const a=t["id"],r=t["name"],s="\n          SELECT\n            correctedViewsDelta,\n            DATE(captureDate, 'unixepoch') AS capturedOn\n          FROM\n            daily_data\n          WHERE\n            channelId = $channelId AND\n            DATE(captureDate, 'unixepoch') >= DATE($start, 'unixepoch') AND\n            DATE(captureDate, 'unixepoch') <= DATE($end, 'unixepoch')\n          ORDER BY\n            captureDate",u=this._execQueryAndFetchResults(s,{$start:e,$end:n,$channelId:a}),i=u.map((e=>[e["capturedOn"],e["correctedViewsDelta"]]));c.push({name:r,data:i})})),c}getViewsBySubscribers(e,n,t){const a="SELECT\n                    name,\n                    channelId,\n                    AVG(correctedSubscribers) AS avgSubscribers,\n                    SUM(correctedViewsDelta) AS totalViews\n                  FROM\n                    daily_data\n                  LEFT JOIN channels ON channels.id = channelId\n                  WHERE\n                    DATE(captureDate, 'unixepoch') >= DATE($start, 'unixepoch')\n                    AND DATE(captureDate, 'unixepoch') <= DATE($end, 'unixepoch')\n                    AND (\n                      channelId IN (\n                        SELECT\n                          channelId\n                        FROM\n                          (\n                            SELECT\n                              channelId,\n                              SUM(correctedViewsDelta) as sum_views\n                            FROM\n                              daily_data\n                            GROUP BY\n                              channelId\n                            ORDER BY\n                              sum_views DESC\n                            LIMIT\n                              $topX\n                          )\n                      ) OR channelId IN (\n                        SELECT\n                          channelId\n                        FROM\n                          (\n                            SELECT\n                              channelId,\n                              AVG(correctedSubscribers) as avg_subscribers\n                            FROM\n                              daily_data\n                            GROUP BY\n                              channelId\n                            ORDER BY\n                              avg_subscribers DESC\n                            LIMIT\n                              $topX\n                          )\n                      )\n                    )\n                  GROUP BY\n                    channelID\n                  ORDER BY\n                    totalViews DESC\n                  LIMIT\n                    $topX",r=this._execQueryAndFetchResults(a,{$start:e,$end:n,$topX:t}),c=[];return r.forEach((e=>{c.push({name:e["name"],data:[[Math.ceil(e["avgSubscribers"]),e["totalViews"]]]})})),c}getViewsByChannelAndGrouping(e,n){const t="SELECT\n                      channelId,\n                      channels.url,\n                      channels.grouping,\n                      channels.name,\n                      SUM(correctedViewsDelta) AS totalViews,\n                      CAST(\n                        100 * SUM(correctedViewsDelta) AS REAL\n                      ) / grouping_sum.totalViews AS shareOfGrouping\n                    FROM\n                      channels\n                      LEFT JOIN daily_data ON channels.id = daily_data.channelId\n                      LEFT JOIN (\n                        SELECT\n                          grouping,\n                          SUM(correctedViewsDelta) AS totalViews\n                        FROM\n                          channels\n                          LEFT JOIN daily_data ON channels.id = daily_data.channelId\n                        GROUP by\n                          channels.grouping\n                      ) AS grouping_sum ON grouping_sum.grouping = channels.grouping\n                    WHERE\n                        DATE(captureDate, 'unixepoch') >= DATE($start, 'unixepoch')\n                        AND DATE(captureDate, 'unixepoch') <= DATE($end, 'unixepoch')\n                    GROUP BY\n                      channelId\n                    ORDER BY\n                      channels.grouping",a=this._execQueryAndFetchResults(t,{$start:e,$end:n}),r=[];var c="",s={};return a.forEach((e=>{const n={x:e["name"],y:e["totalViews"],url:e["url"],id:e["channelId"],shareOfGrouping:null==e["shareOfGrouping"]?0:e["shareOfGrouping"].toFixed(1)},t=e["grouping"];""==c&&(s={name:t,data:[]},c=t),t==c?s.data.push(n):(r.push(s),s={name:t,data:[n]},c=t)})),r.push(s),r}getViewsByGrouping(e,n){const t="SELECT\n                    channels.grouping,\n                    SUM(correctedViewsDelta) AS totalViews\n                  FROM\n                    channels\n                    LEFT JOIN daily_data ON channels.id = daily_data.channelId\n                  WHERE\n                    DATE(captureDate, 'unixepoch') > DATE($start, 'unixepoch')\n                    AND DATE(captureDate, 'unixepoch') < DATE($end, 'unixepoch')\n                  GROUP BY\n                    grouping\n                  ORDER BY\n                    totalViews DESC",a=this._execQueryAndFetchResults(t,{$start:e,$end:n}),r={};return a.forEach((e=>{r[e["grouping"]]=Number(e["totalViews"])})),r}getViewsByGroupingAndDate(e,n){const t="SELECT\n                    channels.grouping,\n                    strftime(\n                      \"%m/%d/%Y\", captureDate, 'unixepoch'\n                    ) AS captureDateStr,\n                    SUM(correctedViewsDelta) AS totalViews\n                  FROM\n                    channels\n                    LEFT JOIN daily_data ON channels.id = daily_data.channelId\n                  WHERE\n                    DATE(captureDate, 'unixepoch') > DATE($start, 'unixepoch')\n                    AND DATE(captureDate, 'unixepoch') < DATE($end, 'unixepoch')\n                  GROUP BY\n                    grouping,\n                    captureDate\n                  ORDER BY\n                    grouping",a=this._execQueryAndFetchResults(t,{$start:e,$end:n}),r=[];return a.forEach((e=>{const n=r.find((n=>n["name"]===e["grouping"]));void 0!==n?n.data.push([e["captureDateStr"],e["totalViews"]]):r.push({name:e["grouping"],data:[[e["captureDateStr"],e["totalViews"]]]})})),r}getChennelsViewsByDate(e,n,t){const a="SELECT\n                    strftime(\n                      \"%m/%d/%Y\", captureDate, 'unixepoch'\n                    ) AS captureDateStr,\n                    correctedViewsDelta AS views\n                  FROM\n                    daily_data\n                  WHERE\n                    DATE(captureDate, 'unixepoch') > DATE($start, 'unixepoch')\n                    AND DATE(captureDate, 'unixepoch') < DATE($end, 'unixepoch')\n                    AND channelId = $channelId",r=this._execQueryAndFetchResults(a,{$start:e,$end:n,$channelId:t}),c=[];return r.forEach((e=>{c.push([e["captureDateStr"],e["views"]])})),c}getChennelsSubscribersByDate(e,n,t){const a="SELECT\n                    strftime(\n                      \"%m/%d/%Y\", captureDate, 'unixepoch'\n                    ) AS captureDateStr,\n                    correctedSubscribers AS subscribers\n                  FROM\n                    daily_data\n                  WHERE\n                    DATE(captureDate, 'unixepoch') > DATE($start, 'unixepoch')\n                    AND DATE(captureDate, 'unixepoch') < DATE($end, 'unixepoch')\n                    AND channelId = $channelId",r=this._execQueryAndFetchResults(a,{$start:e,$end:n,$channelId:t}),c=[];return r.forEach((e=>{c.push([e["captureDateStr"],e["subscribers"]])})),c}getViewsByGroupingAndDayOfWeek(e,n){const t=691200;n-e<t&&(e=n-(t+100));const a="SELECT\n                    channels.grouping,\n                    CASE CAST (strftime('%w', captureDate, 'unixepoch') AS INTEGER)\n                      WHEN 0 then 'Sunday'\n                      when 1 then 'Monday'\n                      when 2 then 'Tuesday'\n                      when 3 then 'Wednesday'\n                      when 4 then 'Thursday'\n                      when 5 then 'Friday'\n                      else 'Saturday' end as captureDateStr,\n                    SUM(correctedViewsDelta) AS totalViews\n                  FROM\n                    channels\n                    LEFT JOIN daily_data ON channels.id = daily_data.channelId\n                  WHERE\n                    DATE(captureDate, 'unixepoch') > DATE($start, 'unixepoch')\n                    AND DATE(captureDate, 'unixepoch') < DATE($end, 'unixepoch')\n                  GROUP BY\n                    grouping,\n                    strftime('%w', captureDate, 'unixepoch')\n                  ORDER BY\n                    strftime('%w', captureDate, 'unixepoch')",r=this._execQueryAndFetchResults(a,{$start:e,$end:n}),c=[];return r.forEach((e=>{const n=c.find((n=>n["name"]===e["grouping"]));void 0!==n?n.data.push(e["totalViews"]):c.push({name:e["grouping"],data:[e["totalViews"]]})})),c}getChannelViewsByDayOfWeek(e,n,t){const a=691200;n-e<a&&(console.log("adjusted start"),e=n-(a+100));const r="SELECT\n                    CASE CAST (strftime('%w', captureDate, 'unixepoch') AS INTEGER)\n                      WHEN 0 then 'Sunday'\n                      when 1 then 'Monday'\n                      when 2 then 'Tuesday'\n                      when 3 then 'Wednesday'\n                      when 4 then 'Thursday'\n                      when 5 then 'Friday'\n                      else 'Saturday' end as captureDateStr,\n                    SUM(correctedViewsDelta) AS views\n                  FROM\n                    daily_data\n                  WHERE\n                    DATE(captureDate, 'unixepoch') > DATE($start, 'unixepoch')\n                    AND DATE(captureDate, 'unixepoch') < DATE($end, 'unixepoch')\n                    AND channelId = $channelId\n                  GROUP BY\n                    captureDateStr\n                  ORDER BY\n                    strftime('%w', captureDate, 'unixepoch')",c=this._execQueryAndFetchResults(r,{$start:e,$end:n,$channelId:t}),s=[];return c.forEach((e=>{s.push(e["views"])})),s}getChannelShareByDate(e,n,t){const a=691200;n-e<a&&(e=n-(a+100));const r="SELECT\n                    daily_data.captureDate,\n                    CAST(100 * correctedViewsDelta AS REAL) / daily_sums.daysSum AS channelShare,\n                    strftime(\n                      \"%m/%d/%Y\", daily_data.captureDate, 'unixepoch'\n                    ) AS captureDateStr\n                  FROM\n                    daily_data\n                    LEFT JOIN (\n                      SELECT\n                        SUM(correctedViewsDelta) as daysSum,\n                        captureDate\n                      FROM\n                        daily_data\n                      GROUP BY\n                        captureDate\n                    ) AS daily_sums ON daily_data.captureDate = daily_sums.captureDate\n                  WHERE\n                    DATE(daily_data.captureDate, 'unixepoch') > DATE($start, 'unixepoch')\n                    AND DATE(daily_data.captureDate, 'unixepoch') < DATE($end, 'unixepoch')\n                    AND channelId = $channelId",c=this._execQueryAndFetchResults(r,{$start:e,$end:n,$channelId:t}),s=[];return c.forEach((e=>{s.push([e["captureDateStr"],e["channelShare"]])})),s}_execQueryAndFetchResults(e,n){var t=this.db.prepare(e);t.bind(n);const a=[];while(t.step())a.push(t.getAsObject(null,{useBigInt:!0}));return a}_resultsToDictionaries(e,n){const t=[];return n.forEach((n=>{const a={};e.forEach(((e,t)=>a[e]=n[t])),t.push(a)})),t}_cryptJsWordArrayToUint8Array(e){const n=e.sigBytes,t=e.words,a=new Uint8Array(n);var r=0,c=0;while(1){if(r==n)break;var s=t[c++];if(a[r++]=(4278190080&s)>>>24,r==n)break;if(a[r++]=(16711680&s)>>>16,r==n)break;if(a[r++]=(65280&s)>>>8,r==n)break;a[r++]=255&s}return a}}},7217:(e,n,t)=>{"use strict";t.d(n,{Z:()=>E});var a=t(9835);function r(e,n,t,r,c,s){const u=(0,a.up)("q-date"),i=(0,a.up)("q-popup-proxy"),d=(0,a.up)("q-btn");return(0,a.wg)(),(0,a.j4)(d,{icon:"event",color:"primary",label:"Select Report Period",push:""},{default:(0,a.w5)((()=>[(0,a.Wm)(i,{"transition-show":"scale","transition-hide":"scale"},{default:(0,a.w5)((()=>[(0,a.Wm)(u,{modelValue:r.dateRange,"onUpdate:modelValue":n[0]||(n[0]=e=>r.dateRange=e),minimal:"",range:"",square:"",onRangeEnd:r.reportRequested},null,8,["modelValue","onRangeEnd"])])),_:1})])),_:1})}var c=t(499);const s={props:{from:{required:!0,type:String},to:{required:!0,type:String}},emits:["reportRequested"],setup(e,{emit:n}){const t=(0,c.iH)({from:e.from,to:e.to}),a=e=>{n("reportRequested",t.value)};return{reportRequested:a,dateRange:t}}};var u=t(1639),i=t(4455),d=t(2765),o=t(6711),h=t(9984),l=t.n(h);const p=(0,u.Z)(s,[["render",r]]),E=p;l()(s,"components",{QBtn:i.Z,QPopupProxy:d.Z,QDate:o.Z})},2480:()=>{},7607:()=>{},803:()=>{}}]);